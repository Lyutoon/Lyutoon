{"meta":{"title":"Lyutoon's blog","subtitle":"","description":"技术&生活","author":"Lyutoon","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Pollard Rho Algorithm Study","slug":"Pollard Rho","date":"2020-11-17T16:00:00.000Z","updated":"2020-11-18T07:14:18.613Z","comments":true,"path":"2020/11/18/Pollard Rho/","link":"","permalink":"http://example.com/2020/11/18/Pollard%20Rho/","excerpt":"了解了Pollard p-1 算法,来看看Pollard Rho算法又能玩出什么新花样吧！","text":"一、引言在上一篇博客中,我们了解了Pollard p-1 算法,这次,请随我看看另一个名叫Pollard Rho的算法又能对大整数分解问题提供什么帮助吧！不过同样的,大整数分解问题在因子选取得当的情况下,要想解决它是极为困难的,因此,Pollard Rho也有它自己的适用条件,下面,我们开始正式介绍这个未曾谋面的算法吧！ 二、Pollard Rho算法(1) 适用条件Pollard Rho算法可以分解大整数是基于大整数$n=pq$中$p$和$q$之间有一个因子很小,在此情况下,我们可以利用该算法完成对$n$的分解。 (2) 基本思想Pollard Rho算法其实是基于寻找指定哈希函数的碰撞的思想才设计的算法。如果我们可以找到不相等的$x$和$x’$并且使得： x\\,mod\\,p=x'\\,mod\\,p那么我们就可以知道$x$和$x’$其实相差$p$的整数倍,由此我们可以知道$gcd(x-x’,n)$如果不是$1$也不是$n$,那么我们就成功分解了。 (3) 具体原理首先我们先了解一下密码学中一个对哈希函数的经典攻击方式:生日攻击,其主要原理是生日悖论。(在此先简单介绍一下,以后会出一篇专门的文章来记录这个方法) 12生日悖论：如果一个房间里有n个人,那么在不考虑特殊因素的前提下,例如闰年、双胞胎,假设一年365日出生概率是平均分布的,需要多少个人才可以保证在这n个人中有50%的概率出现两个人生日相同呢？答案是n&#x3D;23。更有趣的是当n&#x3D;57的时候这个概率竟然高达99%。有兴趣的朋友可以了解一下具体的证明,涉及到简单的概率论知识。生日攻击：生日攻击是基于生日悖论问题的扩展版本,考虑一个值域有n个元素的哈希函数h(x),那么利用与推导生日悖论相似的方法,我们可以得出,如果要使此哈希函数有至少50%的概率产生碰撞,则大约需要1.17√n次不同的x的尝试。 我们考虑一个哈希函数$h:\\left\\{0,1,\\dots,n-1\\right\\}\\rightarrow \\left\\{0,1,\\dots,p-1\\right\\}$,定义为$h(x)=x\\,mod\\,p$. 那么我们由生日悖论可以知道我们如果随意选择$X\\subseteq \\left\\{0,1,\\dots,n-1\\right\\}$,$|X|=1.17\\sqrt p$则有： Pr[\\exist x,x'\\in X\\,s.t.\\,(x\\neq x')\\and(h(x)=h(x'))]\\ge\\frac{1}{2}但是,我们对这个算法进行分析的话,可以发现,如果我们用简单的$h(x)=x\\,mod\\,p$作为哈希函数,则要计算$\\dbinom{|X|}{2}&gt;\\frac{p}{2}$次$gcd(x,x’)$才可以找到这个公因数,复杂度太高了(甚至要比遍历$n$的复杂度还高2333)。因此我们要设计一个比较合理的哈希函数来降低这个复杂度。 考虑一个多项式函数$f(x)=x^2+a$,在Pollard Rho算法中,$a$通常取为$1$。我们假设映射$x\\mapsto f(x)\\,mod\\,p$表现得像一个随机映射(事实上在大多数时候就是表现得像随机映射),主要是为了使这个算法获得的值更加均匀,防止出现像$h(x)$一样的那种遍历式复杂度,同时也可以使这个哈希函数更加像一个$oracle\\,\\,modle$,这样才可以使生日攻击更有效。令$x_1\\in\\mathbb{Z_n}$,考虑一个序列$x_1,x_2,\\dots,$满足： x_j=f(x_{j-1})\\,mod\\,n\\quad(j\\ge2)而我们就是要在这个序列中找到$x_i,x_j\\,s.t.\\,gcd(x_i-x_j,n)&gt;1$. 假设$x_i\\equiv x_j\\,mod\\,p$,那么${x_i}^2+1\\equiv {x_j}^2+1\\,mod\\,p$,而$x_{i+1}=f(x_i)$,因此,我们可以推断出$x_{i+1}\\equiv x_{j+1}\\,mod\\,p$,一直这样递推下去那么我们可以得到结论： 如果x_i\\equiv x_j\\,mod\\,p,那么\\forall \\delta \\ge 0，我们都有x_{i+\\delta}\\equiv x_{j+\\delta}\\,mod\\,p我们令$l=j-i$,那么就有:如果$j’&gt;i’\\ge i$并且$j’-i’$是$l$的整数倍,那么就会得到$x_{i’}\\equiv x_{j’}\\,mod\\,p$。 画成图形大概长这样： 因为长得比较像希腊字母$\\rho$(Rho),因此得名Pollard Rho。 那么我们知道了这些原理,又怎么来找这个$i$和$j$呢？这时候我们可以想,既然里面有一个环,我们是不是可以用弗洛伊德判环法来找出$i$和$j$。那么什么是弗洛伊德判环法呢？ 其实弗洛伊德判环法有点类似于追及问题的一个算法,我们想象一下有两个人在环形操场赛跑,一个人速度是$v$,另一个是$2v$,那么总有一天速度快的那个人要追上速度慢的那个人,并且此时超过了慢速的人一圈。弗洛伊德判环法就是利用了这个性质设计的。 在此处,我们令一个$x$每次套上一层$f(x)$,另一个$x$每次套上两层$f(x)$。举个例子,如果从$x_0$开始,那么慢的那个下一次应该是$f(x_0)\\,mod\\,n=x_1$,而快的那个则是$f(f(x_0))=x_2$这样子。也就是说$x_{快}=2x_{慢}$。 这样一来如果我们在这个追及过程中出现了$gcd(x_{快}-x_{慢},n)\\notin\\left\\{1,n\\right\\}$,则分解成功，找,了$p$。 (4) 伪代码和代码实现伪代码： 代码实现 123456789101112131415161718192021222324252627282930from libnum import *from Crypto.Util.number import *def fmod(x): return x**2 + 1def Pollard_Rho(n): # x的初始值随意 x = 2 _x = fmod(x) p = gcd(x - _x, n) while p == 1: x = fmod(x) _x = fmod(fmod(_x)) p = gcd(x - _x, n) if p == n: print(&#x27;[+] Failed&#x27;) else: print(&#x27;[+] Done! Find p:&#x27;, p) print(&#x27;[+] n =&#x27;, p, &#x27;*&#x27;, n//p) return pn = 29 * getPrime(1024)p = Pollard_Rho(n)&quot;&quot;&quot;output:[+] Done! Find p: 29[+] n = 29 * 160694390601720080215891446309097504078829401059357899217343658521336854029149607444794320922162546033653074554226172627302357473733569083712496339647105124330897484369667963992392644555310859380596962866685705240364320193367410855673391408253447824021633317047996966395554088771201084757899703925555609534083&quot;&quot;&quot; 整个代码跑起来不到1s,因此我们可以看出如果一个大整数中有较小的素数,我们可以很快地将其分解出来。 三、结语通过这个算法,告诫我们在RSA等依赖大整数分解困难性的加密系统选取大整数的时候,两个素数不要相差太远,尽量选取同样比特的素数效果会更好,可以有效抵御Pollard Rho算法的攻击。 感谢大家看到这里,今后我还会更新一些有趣的密码学中的算法,希望可以让大家收获知识和乐趣。","categories":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"},{"name":"algorithm","slug":"cryptography/algorithm","permalink":"http://example.com/categories/cryptography/algorithm/"}],"tags":[]},{"title":"Pollard p-1 Algorithm (科普向)","slug":"Pollard_p-1 Algorithm","date":"2020-11-16T16:00:00.000Z","updated":"2020-11-18T07:15:01.244Z","comments":true,"path":"2020/11/17/Pollard_p-1 Algorithm/","link":"","permalink":"http://example.com/2020/11/17/Pollard_p-1%20Algorithm/","excerpt":"Pollard p-1 大整数分解算法背后的数学秘密。","text":"一、引言当我们首先接触到这个陌生的算法的时候,肯定想要知道这个算法是干什么用的。对于Pollard p-1算法,它可以在一定条件下完成对某些具有特定性质的大整数的分解问题。那么,什么是大整数分解问题？为何它如此重要？这个算法又在什么条件下用什么数学原理可以完成这一问题呢？接下来我会慢慢讲解。 二、大整数分解问题关于大整数分解问题,未接触过密码学的朋友们请想像一下自己对大整数的理解,何为大整数？一千万？一亿？一千亿？其实这都不算是足够作为密码学体制中严格意义的大整数。在密码学中,一般的RSA加密体制用的模数n的强度为1024bit或者更强的2048bit,也就是意味着是$2^{1204} \\sim 2^{2048}$这样的数字才可被称为可用于加密的大整数。大整数分解就是把这个大整数分解成为一个一个素数的乘积。而我们为什么要对它进行分解呢？这就要提到刚刚我们讲过的RSA加密体制了。 RSA加密体制是典型的公钥密码体系,而它的应用也算是十分广泛,我们在生成github的ssh密钥的命令ssh-keygen -t rsa -C中就出现了它的身影。而RSA之所以保密性如此强大,其背后的数学原理就是大整数分解的困难性。下面我们来具体看看RSA的做法： 首先Alice选择两个大素数(一般为512bit强度)$p$和$q$,计算$n=p\\cdot q$作为公钥的一部分。接下来选择一个较大整数$e$,满足$gcd(e,\\phi(n)) = 1$,其中$\\phi(n)$是n的欧拉函数。一般来说,通用的$e=65537$,太大太小都容易遭受攻击(具体以后会讲)。这样我们就得到了一组公钥$(e,n)$。 之后,Alice根据$p$和$q$来确定私钥$d = e^{-1}mod\\phi(n)$。 接下来,因为公钥$(e,n)$是公开的,因此如果Bob想对Alice发消息,那么就可以对明文$m$采用公钥进行加密,得到密文$c$传输给Alice,Alice对其加密后的密文用私钥$d$进行解密,即可恢复明文$m$。具体实现过程如下： c = m^e mod\\,n m = c^d mod\\,n具体的数学原理涉及到简单的数论知识：(如果看不懂请继续看下去,在pollard p-1算法中会讲解简单的数论知识,再回过头就明白啦) m = c^dmod\\,n = m^{ed}mod\\,n = m^{k\\phi(n)+1}mod\\,n=m\\,mod\\,n讲完了RSA 的实现之后,我们不禁想到：“如果我们知道n的因数p和q不就可以恢复d,进而进行消息破解了吗？”正是如此,如果我们可以有多项式时间的算法来分解大整数$n$,那么RSA也就不再安全。 三、Pollard p-1 算法1、数论知识的回顾开始之前, 我们要先具备一些数论的知识。 (1) 算数基本定理算术基本定理可表述为：任何一个大于1的自然数$N$,如果$N$不是素数,那么我们都可以把它分解成有限个素数的乘积。写成公式为： N=p_1^{e_1}p_2^{e_2}\\cdots p_k^{e_k}其中对于不同的$i$和$j$,$p_i^{e_i}\\neq p_j^{e_j}$ (2) 同余我们说a和b模n同余指的是两个数除以n的余数是相同的,记作$a\\equiv b\\,mod\\,n$ (3) Fermat’s Little Theorem如果p是一个质数,而整数a不是p的倍数,则有$a^{p-1}\\equiv 1\\,mod\\,p$。 (4) Euler’s $\\phi$ Function’s Property欧拉函数的性质是费马小定理的推广,也是RSA解密的核心数学原理,具体的表达式为：$a^{\\phi(p)}\\equiv 1\\, mod\\,p$,其中a不是p的倍数。 2、Pollard p-1 算法解析了解了以上数论知识时候,我们就可以开始学习Pollard p-1算法了！(此处针对的是$n=pq$,$p$和$q$为素数的情况,多素因子的情况其实是类似的,为了容易理解,此处取$n=pq$的情况。) (1) 适用条件首先,Pollard p-1算法是有使用条件的：$n=pq$,其中$p-1$是$B-smooth$的。何为$B-smooth$呢？其实就是如果将$p-1$用算数基本定理分解成$p-1=p_1^{e_1}p_2^{e_2}\\cdots p_k^{e_k}$的形式,对于每个$P_i^{e_i}$都小于等于某个特定的整数$B$,那么我们就说$p-1$是$B-smooth$的,其实就是$p-1$的素因子在一块数域里面分布地比较平滑。 (2) 主要思想我们主要思想是：$2^{B!}-1$是p的倍数,或者写为$2^{B!}\\equiv 1\\,mod\\,p$。下面我们来证明一下： 首先我们知道$p$的每一个$p_i^{e_i}$都小于等于$B$,而且对于不同的$i$,$p_i^{e_i}$也是不相等的,因此,对于每一个$p_i^{e_i}$,都包含在$[2,B]$这个区间内。因此$B!$是$p-1$的倍数,或者写为：$B!=k(p-1)$,$k$是大于0的整数。 有了这个条件,我们就可以得到：$2^{B!}\\equiv 2^{k(p-1)}\\,mod\\,p$,而我们应用学过的费马小定理可以发现：$2^{B!}\\equiv 2^{k(p-1)}\\,mod\\,p \\equiv 1\\,mod\\,p$ 到此我们就证明了$2^{B!}-1$是$p$的倍数这件事,聪明的朋友应该已经发现了,如果我们对$2^{B!}-1$和$n$求最大公因数,我们就可以得到$p$的准确值,因为$n$只有两个不相等素因数$p$和$q$。 (3) 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from random import randint# gcd 算法,或者直接用libnum的libnum.gcddef gcd(a, b): if a == 0: return b if b == 0: return a while b: a, b = b, a % b return abs(a)#适用于不那么大的整数,并且可以输出满足条件的最小的Bdef pollard_p_small(n): B = 2 while True: a = 2 for i in range(2, B+1): a = pow(a, i, n) d = gcd(a-1, n) if d != 1 and d != n: print(&#x27;[+] Find p:&#x27;, d) print(&#x27;[+] Find min_B:&#x27;, B) return d, B B += 1#大整数(只进行了二分查找,还是挺慢的,暂时没有太多考虑优化问题)def pollard_p_big(n): #上限可以自己定,一般来说n就够了 B = randint(2, n) while True: a = 2 for i in range(2, B+1): a = pow(a, i, n) d = gcd(a-1, n) #此处的步长为1,在大整数的时候步长可以设长一点,为了节省时间,使B的选取更均匀 if d == 1: B = randint(B+1, n) elif d == n: B = randint(2, B-1) else: print(&#x27;[+] Find p:&#x27;, d) return dn1 = 262063n2 = 9420457pollard_p_small(n1)pollard_p_small(n2)&quot;&quot;&quot;&quot;output:[+] Find p: 521[+] Find min_B: 13[+] Find p: 2351[+] Find min_B: 47&quot;&quot;&quot;&quot; 四、结语该算法提醒我们在RSA素数生成的时候,不要选取$B-smooth$的素数,这样可以有效防止Pollard p-1算法的攻击。 感谢大家能读到这里,希望看完我的文章大家可以收获一些知识和乐趣,以后我会再更新更多的有关密码学的科普和解析博客,也会更新我最近的所思所想,感谢大家的阅读。","categories":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"},{"name":"algorithm","slug":"cryptography/algorithm","permalink":"http://example.com/categories/cryptography/algorithm/"}],"tags":[]}],"categories":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"},{"name":"algorithm","slug":"cryptography/algorithm","permalink":"http://example.com/categories/cryptography/algorithm/"}],"tags":[]}