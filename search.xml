<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pollard Rho Algorithm Study</title>
      <link href="2020/11/18/Pollard%20Rho/"/>
      <url>2020/11/18/Pollard%20Rho/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>在上一篇博客中,我们了解了Pollard p-1 算法,这次,请随我看看另一个名叫<strong>Pollard Rho</strong>的算法又能对大整数分解问题提供什么帮助吧！不过同样的,大整数分解问题在因子选取得当的情况下,要想解决它是极为困难的,因此,Pollard Rho也有它自己的适用条件,下面,我们开始正式介绍这个未曾谋面的算法吧！</p><h2 id="二、Pollard-Rho算法"><a href="#二、Pollard-Rho算法" class="headerlink" title="二、Pollard Rho算法"></a>二、Pollard Rho算法</h2><h3 id="1-适用条件"><a href="#1-适用条件" class="headerlink" title="(1) 适用条件"></a>(1) 适用条件</h3><p>Pollard Rho算法可以分解大整数是基于大整数$n=pq$中$p$和$q$之间有一个因子很小,在此情况下,我们可以利用该算法完成对$n$的分解。</p><h3 id="2-基本思想"><a href="#2-基本思想" class="headerlink" title="(2) 基本思想"></a>(2) 基本思想</h3><p>Pollard Rho算法其实是基于<strong>寻找指定哈希函数的碰撞</strong>的思想才设计的算法。如果我们可以找到不相等的$x$和$x’$并且使得：</p><script type="math/tex; mode=display">x\,mod\,p=x'\,mod\,p</script><p>那么我们就可以知道$x$和$x’$其实相差$p$的整数倍,由此我们可以知道$gcd(x-x’,n)$如果不是$1$也不是$n$,那么我们就成功分解了。</p><h3 id="3-具体原理"><a href="#3-具体原理" class="headerlink" title="(3) 具体原理"></a>(3) 具体原理</h3><p>首先我们先了解一下密码学中一个对哈希函数的经典攻击方式:<strong>生日攻击</strong>,其主要原理是<strong>生日悖论</strong>。(在此先简单介绍一下,以后会出一篇专门的文章来记录这个方法)</p><blockquote><p><strong>生日悖论</strong>：如果一个房间里有n个人,那么在不考虑特殊因素的前提下,例如闰年、双胞胎,假设一年365日出生概率是平均分布的,需要多少个人才可以保证在这n个人中有50%的概率出现两个人生日相同呢？答案是n=23。更有趣的是当n=57的时候这个概率竟然高达99%。有兴趣的朋友可以了解一下具体的证明,涉及到简单的概率论知识。<br><strong>生日攻击</strong>：生日攻击是基于生日悖论问题的扩展版本,考虑一个值域有n个元素的哈希函数h(x),那么利用与推导生日悖论相似的方法,我们可以得出,如果要使此哈希函数有至少50%的概率产生碰撞,则大约需要1.17$\sqrt n$次不同的x的尝试。</p></blockquote><p>我们考虑一个哈希函数$h:\left\{0,1,\dots,n-1\right\}\rightarrow \left\{0,1,\dots,p-1\right\}$,定义为$h(x)=x\,mod\,p$.</p><p>那么我们由生日悖论可以知道我们如果随意选择$X\subseteq \left\{0,1,\dots,n-1\right\}$,$|X|=1.17\sqrt p$则有：</p><script type="math/tex; mode=display">Pr[\exists x,x'\in X\,s.t.\,(x\neq x')\land(h(x)=h(x'))]\ge\frac{1}{2}</script><p>但是,我们对这个算法进行分析的话,可以发现,如果我们用简单的$h(x)=x\,mod\,p$作为哈希函数,则要计算$\dbinom{|X|}{2}&gt;\frac{p}{2}$次$gcd(x,x’)$才可以找到这个公因数,复杂度太高了(甚至要比遍历$n$的复杂度还高2333)。因此我们要设计一个比较合理的哈希函数来降低这个复杂度。</p><p>考虑一个多项式函数$f(x)=x^2+a$,在Pollard Rho算法中,$a$通常取为$1$。我们假设映射$x\mapsto f(x)\,mod\,p$表现得像一个随机映射(事实上在大多数时候就是表现得像随机映射),主要是为了使这个算法获得的值更加均匀,防止出现像$h(x)$一样的那种遍历式复杂度,同时也可以使这个哈希函数更加像一个$oracle\,\,modle$,这样才可以使生日攻击更有效。令$x_1\in\mathbb{Z_n}$,考虑一个序列$x_1,x_2,\dots,$满足：</p><script type="math/tex; mode=display">x_j=f(x_{j-1})\,mod\,n\quad(j\ge2)</script><p>而我们就是要在这个序列中找到$x_i,x_j\,s.t.\,gcd(x_i-x_j,n)&gt;1$.</p><p>假设$x_i\equiv x_j\,mod\,p$,那么${x_i}^2+1\equiv {x_j}^2+1\,mod\,p$,而$x_{i+1}=f(x_i)$,因此,我们可以推断出$x_{i+1}\equiv x_{j+1}\,mod\,p$,一直这样递推下去那么我们可以得到结论：</p><script type="math/tex; mode=display">如果x_i\equiv x_j\,mod\,p,那么\forall \delta \ge 0，我们都有x_{i+\delta}\equiv x_{j+\delta}\,mod\,p</script><p>我们令$l=j-i$,那么就有:如果$j’&gt;i’\ge i$并且$j’-i’$是$l$的整数倍,那么就会得到$x_{i’}\equiv x_{j’}\,mod\,p$。</p><p>画成图形大概长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyutoon/picture@1.04/Rho.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Lyutoon/picture@1.04/Rho.png" srcset="data:image/png;base64,666" alt="alt" style="zoom:50%;" /></p><p>因为长得比较像希腊字母$\rho$(Rho),因此得名Pollard Rho。</p><p>那么我们知道了这些原理,又怎么来找这个$i$和$j$呢？这时候我们可以想,既然里面有一个环,我们是不是可以用<strong>弗洛伊德判环法</strong>来找出$i$和$j$。那么什么是弗洛伊德判环法呢？</p><p>其实弗洛伊德判环法有点类似于追及问题的一个算法,我们想象一下有两个人在环形操场赛跑,一个人速度是$v$,另一个是$2v$,那么总有一天速度快的那个人要追上速度慢的那个人,并且此时超过了慢速的人一圈。弗洛伊德判环法就是利用了这个性质设计的。</p><p>在此处,我们令一个$x$每次套上一层$f(x)$,另一个$x$每次套上两层$f(x)$。举个例子,如果从$x_0$开始,那么慢的那个下一次应该是$f(x_0)\,mod\,n=x_1$,而快的那个则是$f(f(x_0))=x_2$这样子。也就是说$x_{快}=2x_{慢}$。</p><p>这样一来如果我们在这个追及过程中出现了$gcd(x_{快}-x_{慢},n)\notin\left\{1,n\right\}$,则分解成功，找,了$p$。</p><p>整个代码的复杂度为$O(n^{1/4})$</p><h3 id="4-伪代码和代码实现"><a href="#4-伪代码和代码实现" class="headerlink" title="(4) 伪代码和代码实现"></a>(4) 伪代码和代码实现</h3><p>伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Lyutoon/picture@1.04/%E4%BC%AA%E4%BB%A3%E7%A0%81.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Lyutoon/picture@1.04/%E4%BC%AA%E4%BB%A3%E7%A0%81.png" srcset="data:image/png;base64,666" alt="alt" style="zoom:50%;" /></p><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pollard_Rho</span>(<span class="params">n</span>):</span></span><br><span class="line">    f = <span class="keyword">lambda</span> x: (x*x + <span class="number">1</span>) % n</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    _x = f(x)</span><br><span class="line">    p = gcd(x - _x, n)</span><br><span class="line">    <span class="keyword">while</span> p == <span class="number">1</span>:</span><br><span class="line">        x = f(x)</span><br><span class="line">        _x = f(f(_x))</span><br><span class="line">        p = gcd(x - _x, n)</span><br><span class="line">    <span class="keyword">if</span> p == n:</span><br><span class="line">        print(<span class="string">&#x27;[+] Failed&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;[+] Done! Find p:&#x27;</span>, p)</span><br><span class="line">        print(<span class="string">&#x27;[+] n =&#x27;</span>, p, <span class="string">&#x27;*&#x27;</span>, n//p)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">20</span>)</span><br><span class="line">n = p * getPrime(<span class="number">1024</span>)</span><br><span class="line">Pollard_Rho(n)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">[+] Done! Find p: 1003507</span></span><br><span class="line"><span class="string">[+] n = 1003507 * 119194734255586430249491786028030901955714303727483782260194798985850318067046294210092944971608413702515710726741826459609793866216394194576322278249676418761626477844699560122695407656121947507162012151299590017153791311273871754406254980031843483910743861839907953660598736617115028062045825098452377479049</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>因为$p$实在是太小了,整个代码跑起来差不多1s。但是python跑的有点慢,用C的话会快好多。因此我们可以看出如果一个大整数中有较小的素数,我们都可以很快地将其分解出来。</p><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>通过这个算法,告诫我们在RSA等依赖大整数分解困难性的加密系统选取大整数的时候,两个素数不要相差太远,因为<strong>1024bit</strong>和<strong>1024bit</strong>是不一样的,同样是<strong>1024bit</strong>尽量选取同样比特的$pq$效果会更好,不要一个很大一个很小,这样可以有效抵御Pollard Rho算法的攻击。</p><p>感谢大家看到这里,今后我还会更新一些有趣的密码学中的算法,希望可以让大家收获知识和乐趣！</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pollard p-1 Algorithm (科普向)</title>
      <link href="2020/11/17/Pollard_p-1%20Algorithm/"/>
      <url>2020/11/17/Pollard_p-1%20Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>当我们首先接触到这个陌生的算法的时候,肯定想要知道这个算法是干什么用的。对于Pollard p-1算法,它可以在一定条件下完成对某些具有特定性质的大整数的分解问题。那么,什么是大整数分解问题？为何它如此重要？这个算法又在什么条件下用什么数学原理可以完成这一问题呢？接下来我会慢慢讲解。</p><h2 id="二、大整数分解问题"><a href="#二、大整数分解问题" class="headerlink" title="二、大整数分解问题"></a>二、大整数分解问题</h2><p>关于大整数分解问题,未接触过密码学的朋友们请想像一下自己对<strong>大整数</strong>的理解,何为大整数？一千万？一亿？一千亿？其实这都不算是足够作为密码学体制中严格意义的大整数。在密码学中,一般的RSA加密体制用的模数n的强度为<strong>1024bit</strong>或者更强的<strong>2048bit</strong>,也就是意味着是$2^{1204} \sim 2^{2048}$这样的数字才可被称为可用于加密的大整数。大整数分解就是把这个大整数分解成为一个一个素数的乘积。而我们为什么要对它进行分解呢？这就要提到刚刚我们讲过的RSA加密体制了。</p><p>RSA加密体制是典型的公钥密码体系,而它的应用也算是十分广泛,我们在生成github的ssh密钥的命令<code>ssh-keygen -t rsa -C</code>中就出现了它的身影。而RSA之所以保密性如此强大,其背后的数学原理就是<strong>大整数分解的困难性</strong>。下面我们来具体看看RSA的做法：</p><p>首先Alice选择两个<strong>大素数</strong>(一般为512bit强度)$p$和$q$,计算$n=p\cdot q$作为公钥的一部分。接下来选择一个较大整数$e$,满足$gcd(e,\phi(n)) = 1$,其中$\phi(n)$是n的欧拉函数。一般来说,通用的$e=65537$,太大太小都容易遭受攻击(具体以后会讲)。这样我们就得到了一组公钥$(e,n)$。</p><p>之后,Alice根据$p$和$q$来确定私钥$d = e^{-1}mod\phi(n)$。</p><p>接下来,因为公钥$(e,n)$是公开的,因此如果Bob想对Alice发消息,那么就可以对明文$m$采用公钥进行加密,得到密文$c$传输给Alice,Alice对其加密后的密文用私钥$d$进行解密,即可恢复明文$m$。具体实现过程如下：</p><script type="math/tex; mode=display">c = m^e mod\,n</script><script type="math/tex; mode=display">m = c^d mod\,n</script><p>具体的数学原理涉及到简单的数论知识：(如果看不懂请继续看下去,在pollard p-1算法中会讲解简单的数论知识,再回过头就明白啦)</p><script type="math/tex; mode=display">m = c^dmod\,n = m^{ed}mod\,n = m^{k\phi(n)+1}mod\,n=m\,mod\,n</script><p>讲完了RSA 的实现之后,我们不禁想到：<strong>“如果我们知道n的因数p和q不就可以恢复d,进而进行消息破解了吗？”</strong>正是如此,如果我们可以有多项式时间的算法来分解大整数$n$,那么RSA也就不再安全。</p><h2 id="三、Pollard-p-1-算法"><a href="#三、Pollard-p-1-算法" class="headerlink" title="三、Pollard p-1 算法"></a>三、Pollard p-1 算法</h2><h3 id="1、数论知识的回顾"><a href="#1、数论知识的回顾" class="headerlink" title="1、数论知识的回顾"></a>1、数论知识的回顾</h3><p>开始之前,</p><p>我们要先具备一些数论的知识。</p><h4 id="1-算数基本定理"><a href="#1-算数基本定理" class="headerlink" title="(1) 算数基本定理"></a>(1) 算数基本定理</h4><p>算术基本定理可表述为：任何一个大于1的自然数$N$,如果$N$不是素数,那么我们都可以把它分解成有限个素数的乘积。写成公式为：</p><script type="math/tex; mode=display">N=p_1^{e_1}p_2^{e_2}\cdots p_k^{e_k}</script><p>其中对于不同的$i$和$j$,$p_i^{e_i}\neq p_j^{e_j}$</p><h4 id="2-同余"><a href="#2-同余" class="headerlink" title="(2) 同余"></a>(2) 同余</h4><p>我们说a和b模n同余指的是两个数除以n的余数是相同的,记作$a\equiv b\,mod\,n$</p><h4 id="3-Fermat’s-Little-Theorem"><a href="#3-Fermat’s-Little-Theorem" class="headerlink" title="(3) Fermat’s Little Theorem"></a>(3) Fermat’s Little Theorem</h4><p>如果p是一个质数,而整数a不是p的倍数,则有$a^{p-1}\equiv 1\,mod\,p$。</p><h4 id="4-Euler’s-phi-Function’s-Property"><a href="#4-Euler’s-phi-Function’s-Property" class="headerlink" title="(4) Euler’s $\phi$ Function’s Property"></a>(4) Euler’s $\phi$ Function’s Property</h4><p>欧拉函数的性质是费马小定理的推广,也是RSA解密的核心数学原理,具体的表达式为：$a^{\phi(p)}\equiv 1\, mod\,p$,其中a不是p的倍数。</p><h3 id="2、Pollard-p-1-算法解析"><a href="#2、Pollard-p-1-算法解析" class="headerlink" title="2、Pollard p-1 算法解析"></a>2、Pollard p-1 算法解析</h3><p>了解了以上数论知识时候,我们就可以开始学习Pollard p-1算法了！(此处针对的是$n=pq$,$p$和$q$为素数的情况,多素因子的情况其实是类似的,为了容易理解,此处取$n=pq$的情况。)</p><h4 id="1-适用条件"><a href="#1-适用条件" class="headerlink" title="(1) 适用条件"></a>(1) 适用条件</h4><p>首先,Pollard p-1算法是有使用条件的：$n=pq$,其中$p-1$是比较平滑的。那么什么是平滑的呢？其实就是如果将$p-1$用算数基本定理分解成$p-1=p_1^{e_1}p_2^{e_2}\cdots p_k^{e_k}$的形式,对于每个$P_i^{e_i}$都小于等于某个特定的(较小的)整数$B$。</p><h4 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="(2) 主要思想"></a>(2) 主要思想</h4><p>我们主要思想是：$2^{B!}-1$是p的倍数,或者写为$2^{B!}\equiv 1\,mod\,p$。下面我们来证明一下：</p><p>首先我们知道$p-1$的每一个$p_i^{e_i}$都小于等于$B$,而且对于不同的$i$,$p_i^{e_i}$也是不相等的,因此,对于每一个$p_i^{e_i}$,都包含在$[2,B]$这个区间内。因此$B!$是$p-1$的倍数,或者写为：$B!=k(p-1)$,$k$是大于0的整数。</p><p>有了这个条件,我们就可以得到：$2^{B!}\equiv 2^{k(p-1)}\,mod\,p$,而我们应用学过的费马小定理可以发现：$2^{B!}\equiv 2^{k(p-1)}\,mod\,p \equiv 1\,mod\,p$</p><p>到此我们就证明了$2^{B!}-1$是$p$的倍数这件事,聪明的朋友应该已经发现了,如果我们对$2^{B!}-1$和$n$求最大公因数,我们就可以得到$p$的准确值,因为$n$只有两个不相等素因数$p$和$q$。</p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3) 代码实现"></a>(3) 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="comment"># gcd 算法,或者直接用libnum的libnum.gcd</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>: <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>: <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        a, b = b, a % b</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#适用于不那么大的整数,并且可以输出满足条件的最小的B</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_p_small</span>(<span class="params">n</span>):</span></span><br><span class="line">    B = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, B+<span class="number">1</span>):</span><br><span class="line">            a = <span class="built_in">pow</span>(a, i, n)</span><br><span class="line">        d = gcd(a<span class="number">-1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">1</span> <span class="keyword">and</span> d != n:</span><br><span class="line">            print(<span class="string">&#x27;[+] Find p:&#x27;</span>, d)</span><br><span class="line">            print(<span class="string">&#x27;[+] Find min_B:&#x27;</span>, B)</span><br><span class="line">            <span class="keyword">return</span> d, B</span><br><span class="line">        B += <span class="number">1</span></span><br><span class="line"><span class="comment">#大整数(只进行了二分查找,还是挺慢的,暂时没有太多考虑优化问题)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_p_big</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment">#上限可以自己定,一般来说n就够了</span></span><br><span class="line">    B = randint(<span class="number">2</span>, n)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, B+<span class="number">1</span>):</span><br><span class="line">            a = <span class="built_in">pow</span>(a, i, n)</span><br><span class="line">        d = gcd(a<span class="number">-1</span>, n)</span><br><span class="line">        <span class="comment">#此处的步长为1,在大整数的时候步长可以设长一点,为了节省时间,使B的选取更均匀</span></span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            B = randint(B+<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">elif</span> d == n:</span><br><span class="line">            B = randint(<span class="number">2</span>, B<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;[+] Find p:&#x27;</span>, d)</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">n1 = <span class="number">262063</span></span><br><span class="line">n2 = <span class="number">9420457</span></span><br><span class="line">pollard_p_small(n1)</span><br><span class="line">pollard_p_small(n2)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">[+] Find p: 521</span></span><br><span class="line"><span class="string">[+] Find min_B: 13</span></span><br><span class="line"><span class="string">[+] Find p: 2351</span></span><br><span class="line"><span class="string">[+] Find min_B: 47</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>该算法提醒我们在RSA素数生成的时候,不要选取过于$smooth$的素数,这样可以有效防止Pollard p-1算法的攻击。</p><p>感谢大家能读到这里,希望看完我的文章大家可以收获一些知识和乐趣,以后我会再更新更多的有关密码学的科普和解析博客,也会更新我最近的所思所想,感谢大家的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
