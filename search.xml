<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pollard p-1 Algorithm (科普向)</title>
      <link href="2020/11/17/Pollard_p-1%20Algorithm/"/>
      <url>2020/11/17/Pollard_p-1%20Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>当我们首先接触到这个陌生的算法的时候，肯定想要知道这个算法是干什么用的。对于Pollard p-1算法，它可以在一定条件下完成对某些具有特定性质的大整数的分解问题。那么，什么是大整数分解问题？为何它如此重要？这个算法又在什么条件下用什么数学原理可以完成这一问题呢？接下来我会慢慢讲解。</p><h2 id="二、大整数分解问题"><a href="#二、大整数分解问题" class="headerlink" title="二、大整数分解问题"></a>二、大整数分解问题</h2><p>关于大整数分解问题，未接触过密码学的朋友们请想像一下自己对<strong>大整数</strong>的理解，何为大整数？一千万？一亿？一千亿？其实这都不算是足够作为密码学体制中严格意义的大整数。在密码学中，一般的RSA加密体制用的模数n的强度为<strong>1024bit</strong>或者更强的<strong>2048bit</strong>，也就是意味着是$2^{1204} \sim 2^{2048}$这样的数字才可被称为可用于加密的大整数。大整数分解就是把这个大整数分解成为一个一个素数的乘积。而我们为什么要对它进行分解呢？这就要提到刚刚我们讲过的RSA加密体制了。</p><p>RSA加密体制是典型的公钥密码体系，而它的应用也算是十分广泛，我们在生成github的ssh密钥的命令<code>ssh-keygen -t rsa -c</code>中就出现了它的身影。而RSA之所以保密性如此强大，其背后的数学原理就是<strong>大整数分解的困难性</strong>。下面我们来具体看看RSA的做法：</p><p>首先Alice选择两个<strong>大素数</strong>(一般为512bit强度)$p$和$q$,计算$n=p\cdot q$作为公钥的一部分。接下来选择一个较大整数$e$,满足$gcd(e,\phi(n)) = 1$,其中$\phi(n)$是n的欧拉函数。一般来说，通用的$e=65537$,太大太小都容易遭受攻击(具体以后会讲)。这样我们就得到了一组公钥$(e,n)$。</p><p>之后，Alice根据$p$和$q$来确定私钥$d = e^{-1}mod\phi(n)$。</p><p>接下来，因为公钥$(e,n)$是公开的，因此如果Bob想对Alice发消息，那么就可以对明文$m$采用公钥进行加密，得到密文$c$传输给Alice，Alice对其加密后的密文用私钥$d$进行解密，即可恢复明文$m$。具体实现过程如下：</p><script type="math/tex; mode=display">c = m^e mod\,n</script><script type="math/tex; mode=display">m = c^d mod\,n</script><p>具体的数学原理涉及到简单的数论知识：(如果看不懂请继续看下去，在pollard p-1算法中会讲解简单的数论知识，再回过头就明白啦)</p><script type="math/tex; mode=display">m = c^dmod\,n = m^{ed}mod\,n = m^{k\phi(n)+1}mod\,n=m\,mod\,n</script><p>讲完了RSA 的实现之后，我们不禁想到：<strong>“如果我们知道n的因数p和q不就可以恢复d，进而进行消息破解了吗？”</strong>正是如此，如果我们可以有多项式时间的算法来分解大整数$n$，那么RSA也就不再安全。</p><h2 id="三、Pollard-p-1-算法"><a href="#三、Pollard-p-1-算法" class="headerlink" title="三、Pollard p-1 算法"></a>三、Pollard p-1 算法</h2><h3 id="1、数论知识的回顾"><a href="#1、数论知识的回顾" class="headerlink" title="1、数论知识的回顾"></a>1、数论知识的回顾</h3><p>开始之前，</p><p>我们要先具备一些数论的知识。</p><h4 id="1-算数基本定理"><a href="#1-算数基本定理" class="headerlink" title="(1) 算数基本定理"></a>(1) 算数基本定理</h4><p>算术基本定理可表述为：任何一个大于1的自然数$N$，如果$N$不是素数，那么我们都可以把它分解成有限个素数的乘积。写成公式为：</p><script type="math/tex; mode=display">N=p_1^{e_1}p_2^{e_2}\cdots p_k^{e_k}</script><p>其中对于不同的$i$和$j$，$p_i^{e_i}\neq p_j^{e_j}$</p><h4 id="2-同余"><a href="#2-同余" class="headerlink" title="(2) 同余"></a>(2) 同余</h4><p>我们说a和b模n同余指的是两个数除以n的余数是相同的，记作$a\equiv b\,mod\,n$</p><h4 id="3-Fermat’s-Little-Theorem"><a href="#3-Fermat’s-Little-Theorem" class="headerlink" title="(3) Fermat’s Little Theorem"></a>(3) Fermat’s Little Theorem</h4><p>如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}\equiv 1\,mod\,p$。</p><h4 id="4-Euler’s-phi-Function’s-Property"><a href="#4-Euler’s-phi-Function’s-Property" class="headerlink" title="(4) Euler’s $\phi$ Function’s Property"></a>(4) Euler’s $\phi$ Function’s Property</h4><p>欧拉函数的性质是费马小定理的推广，也是RSA解密的核心数学原理，具体的表达式为：$a^{\phi(p)}\equiv 1\, mod\,p$，其中a不是p的倍数。</p><h3 id="2、Pollard-p-1-算法解析"><a href="#2、Pollard-p-1-算法解析" class="headerlink" title="2、Pollard p-1 算法解析"></a>2、Pollard p-1 算法解析</h3><p>了解了以上数论知识时候，我们就可以开始学习Pollard p-1算法了！(此处针对的是$n=pq$，p和q为素数的情况，多素因子的情况其实是类似的，为了容易理解，此处取$n=pq$的情况。)</p><h4 id="1-适用条件"><a href="#1-适用条件" class="headerlink" title="(1) 适用条件"></a>(1) 适用条件</h4><p>首先，Pollard p-1算法是有使用条件的：$n=pq$，其中$p-1$是$B-smooth$的。何为$B-smooth$呢？其实就是如果将$p-1$用算数基本定理分解成$p-1=p_1^{e_1}p_2^{e_2}\cdots p_k^{e_k}$的形式，对于每个$P_i^{e_i}$都小于等于某个特定的整数$B$，那么我们就说$p-1$是$B-smooth$的，其实就是$p-1$的素因子在一块数域里面分布地比较<strong>平滑</strong>。</p><h4 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="(2) 主要思想"></a>(2) 主要思想</h4><p>我们主要思想是：$2^{B!}-1$是p的倍数，或者写为$2^{B!}\equiv 1\,mod\,p$。下面我们来证明一下：</p><p>首先我们知道$p$的每一个$p_i^{e_i}$都小于等于$B$，而且对于不同的$i$，$p_i^{e_i}$也是不相等的，因此，对于每一个$p_i^{e_i}$，都包含在$[2,B]$这个区间内。因此$B!$是$p-1$的倍数，或者写为：$B!=k(p-1)$，$k$是大于0的整数。</p><p>有了这个条件，我们就可以得到：$2^{B!}\equiv 2^{k(p-1)}\,mod\,p$，而我们应用学过的费马小定理可以发现：$2^{B!}\equiv 2^{k(p-1)}\,mod\,p \equiv 1\,mod\,p$</p><p>到此我们就证明了$2^{B!}-1$是p的倍数这件事，聪明的朋友应该已经发现了，如果我们对$2^{B!}-1$和$n$求最大公因数，我们就可以得到$p$的准确值，因为$n$只有两个不相等素因数$p$和$q$。</p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3) 代码实现"></a>(3) 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="comment"># gcd 算法,或者直接用libnum的libnum.gcd</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>: <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>: <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        a, b = b, a % b</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#适用于不那么大的整数,并且可以输出满足条件的最小的B</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_p_small</span>(<span class="params">n</span>):</span></span><br><span class="line">    B = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, B+<span class="number">1</span>):</span><br><span class="line">            a = <span class="built_in">pow</span>(a, i, n)</span><br><span class="line">        d = gcd(a<span class="number">-1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">1</span> <span class="keyword">and</span> d != n:</span><br><span class="line">            print(<span class="string">&#x27;[+] Find p:&#x27;</span>, d)</span><br><span class="line">            print(<span class="string">&#x27;[+] Find min_B:&#x27;</span>, B)</span><br><span class="line">            <span class="keyword">return</span> d, B</span><br><span class="line">        B += <span class="number">1</span></span><br><span class="line"><span class="comment">#大整数(只进行了二分查找,还是挺慢的，暂时没有太多考虑优化问题)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_p_big</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment">#上限可以自己定，一般来说n就够了</span></span><br><span class="line">    B = randint(<span class="number">2</span>, n)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, B+<span class="number">1</span>):</span><br><span class="line">            a = <span class="built_in">pow</span>(a, i, n)</span><br><span class="line">        d = gcd(a<span class="number">-1</span>, n)</span><br><span class="line">        <span class="comment">#此处的步长为1，在大整数的时候步长可以设长一点，为了节省时间，使B的选取更均匀</span></span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            B = randint(B+<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">elif</span> d == n:</span><br><span class="line">            B = randint(<span class="number">2</span>, B<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;[+] Find p:&#x27;</span>, d)</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">n1 = <span class="number">262063</span></span><br><span class="line">n2 = <span class="number">9420457</span></span><br><span class="line">pollard_p_small(n1)</span><br><span class="line">pollard_p_small(n2)</span><br></pre></td></tr></table></figure><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>该算法提醒我们在RSA素数生成的时候，不要选取$B-smooth$的素数，这样可以有效防止Pollard p-1算法的攻击。</p><p>感谢大家能读到这里，希望看完我的文章大家可以收获一些知识和乐趣，以后我会再更新更多的有关密码学的科普和解析博客，也会更新我最近的所思所想，感谢大家的阅读。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
